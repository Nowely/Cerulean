В приложении используется валидация. Вопрос в том, как реализовать ее корректно.

## Тезисы
1. **Интеграция с DataAnnotations**. Имеются разные альтернативы: ручная реализация, `FluentValidation`. Но интереснее всего выглядят атрибуты, которые можно увидеть непосредственно в модели данных;
2. Валидация проводится в **Minimal API**.  Соответственно требуется явный подход;
3. Валидатор находится отдельно от модели. То есть **модель не реализовывает IValidatableObject**. Который ограничиваем возможности остальных тезисов;
4. **FluentValidation имеет интересные идеи**, которые можно перенять. Это: реализация для minimal api, валидаторы в сервисах;
5. Используется подход **валидация через парсинг**. То есть мы на раннем этапе выполняем три задачи: валидируем нормируем и отдаем имутабельную модель;
6. Используем **сплав стандартных подходов**. В частности речь идет о существующих классов и методов, которые можно переиспользовать: ValidationProblem, ValidationAttribute, ValidationResult, ValidationContext.

## Методы решения

### 1. Ручная валидация
Простейший способ — проверить данные вручную внутри обработчика:

```csharp
app.MapPost("/users", (User user) =>
{
    var errors = new Dictionary<string, string[]>();

    if (string.IsNullOrEmpty(user.Name))
        errors.Add("Name", new[] { "Name is required." });

    if (user.Age < 18)
        errors.Add("Age", new[] { "User must be at least 18 years old." });

    if (errors.Count > 0)
        return Results.ValidationProblem(errors);

    // Логика сохранения
    return Results.Ok("User created");
});
```
### 2. Использование FluentValidation
Библиотека **FluentValidation** упрощает сложные сценарии валидации.

**Создание валидатора:**
```csharp
public class UserValidator : AbstractValidator<User>
{
    public UserValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Name is required.")
            .MinimumLength(3).WithMessage("Name must be at least 3 characters.");

        RuleFor(x => x.Age)
            .GreaterThanOrEqualTo(18).WithMessage("User must be adult.");
    }
}
```

**Регистрация валидатора:**
```csharp
builder.Services.AddScoped<IValidator<User>, UserValidator>();
```

**Использование в обработчике:**
```csharp
app.MapPost("/users", (User user, IValidator<User> validator) =>
{
    var validationResult = validator.Validate(user);
    if (!validationResult.IsValid)
        return Results.ValidationProblem(validationResult.ToDictionary());

    // Логика сохранения
    return Results.Ok("User created");
});
```

### 3. Интеграция с DataAnnotations
Если модель уже использует атрибуты `DataAnnotations`, можно вручную вызвать валидацию:

```csharp
app.MapPost("/users", (User user) =>
{
    var validationResults = new List<ValidationResult>();
    var isValid = Validator.TryValidateObject(
        user, 
        new ValidationContext(user), 
        validationResults, 
        validateAllProperties: true
    );

    if (!isValid)
        return Results.ValidationProblem(validationResults
            .GroupBy(v => v.MemberNames.FirstOrDefault() ?? "")
            .ToDictionary(g => g.Key, g => g.Select(e => e.ErrorMessage!).ToArray()));

    return Results.Ok("User created");
});
```

## Автоматизация применения валидации
### 1. Через Endpoint Filter
Для автоматической проверки всех запросов создайте фильтр:

```csharp
public class ValidationFilter<T> : IEndpointFilter
{
    public async ValueTask<object?> InvokeAsync(
        EndpointFilterInvocationContext context,
        EndpointFilterDelegate next)
    {
        var validator = context.HttpContext.RequestServices.GetService<IValidator<T>>();
        if (validator is null)
            return await next(context);

        // Поиск модели типа T в аргументах
        var model = context.Arguments
            .OfType<T>()
            .FirstOrDefault();

        if (model is null)
            return Results.BadRequest("Invalid request format.");

        var validationResult = await validator.ValidateAsync(model);
        if (!validationResult.IsValid)
            return Results.ValidationProblem(validationResult.ToDictionary());

        return await next(context);
    }
}
```

#### Применение фильтра
```csharp
app.MapPost("/users", (User user) =>
{
    // Логика сохранения
    return Results.Ok("User created");
})
.AddEndpointFilter<ValidationFilter<User>>();
```

### 2. Через `BindAsync`
Можно интегрировать валидацию в процесс привязки данных модели:

```csharp
public class User
{
    public string Name { get; set; }
    public int Age { get; set; }

    public static async ValueTask<User?> BindAsync(HttpContext context, ParameterInfo parameter)
    {
        var model = await context.Request.ReadFromJsonAsync<User>();
        var validator = context.RequestServices.GetRequiredService<IValidator<User>>();
        var validationResult = validator.Validate(model!);

        if (!validationResult.IsValid)
        {
            context.Response.StatusCode = 400;
            await context.Response.WriteAsJsonAsync(validationResult.Errors);
            return null;
        }

        return model;
    }
}
```

**Использование**:
```csharp
app.MapPost("/users", (User user) => Results.Ok("User created"));
```

## Пример формирования ответа

Используется `ValidationProblem()`, чтобы возвращать ошибки в формате `ProblemDetails`:

```csharp
if (!validationResult.IsValid)
    return Results.ValidationProblem(
        errors: validationResult.ToDictionary(),
        detail: "Validation failed",
        statusCode: StatusCodes.Status400BadRequest
    );
```

Пример ответа:
```json
{
  "type": "https://tools.ietf.org/html/rfc7231#section-6.5.1",
  "title": "Validation failed",
  "status": 400,
  "errors": {
    "Name": ["Name is required."]
  }
}
```

## Планирование апи

### Создание контента
Модели с валидацией:
```cs
record CreateUserRequest {
	[FromBody] UserCreate User;
	[FromService] UserService Service;
	[FromService] IParser<UserCreate> Parser;
}

record UserCreate {
	[MinLenght(30)]
	string Name;
	[Email]
	string Email;
}
```

Подключение парсера:
```cs
builder.Services.AddScoped<IParser<UserCreate>, UserCreateParser>();
```

1. Кейс создания слишком прост:
	1. Отсутствует нормализация;
	2. Отсутствуют value object (Например, для email. Требуется ли он?);
	3. Можно ли использовать типовой парсер для проведения валидации? А не подключать для каждой модели отдельно?
2. Можно использовать один парсер для всех моделей user? => `UserParser`
3. Метод Parse должен быть асинхронным и обязательно зарегистрирован в Di. Так можно будет проводить валидацию к бд или сетевую.

Использование в обработчике:
```csharp
app.MapPost("/users", (CreateUserRequest request) =>
{
    var parserResult = request.Parser.ParseAsync(request.User);
    if (!parserResult.IsValid)
        return Results.ValidationProblem(parserResult.Errors);

	var result = request.Service.Create(parseResult.Data)
    return Results.Ok("User created", result);
});
```